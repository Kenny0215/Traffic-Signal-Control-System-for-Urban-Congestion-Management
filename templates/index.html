<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>SmartFlow Pro | Collision-Free Turns</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background: #08080a; color: #fff; font-family: 'Inter', sans-serif; overflow: hidden; }
        .blinker { animation: blink 0.3s step-end infinite; }
        @keyframes blink { 50% { fill: transparent; } }
    </style>
</head>
<body class="h-screen flex flex-col p-6">
    <header class="flex justify-between items-center mb-6 bg-[#0c0c0e] p-5 rounded-2xl border border-white/5">
        <div class="flex items-center gap-4">
            <div class="w-10 h-10 bg-indigo-600 rounded-lg flex items-center justify-center font-bold text-white shadow-lg rotate-45"><span class="-rotate-45">+</span></div>
            <div>
                <h1 class="text-sm font-bold uppercase tracking-tight text-white/90">SmartFlow AI Agent</h1>
                <p class="text-[9px] text-white/20 uppercase tracking-widest">Safe Turning Logic Active</p>
            </div>
        </div>
        <div class="text-right">
            <span class="text-white/20 text-[9px] mb-1 uppercase block">Total Throughput</span>
            <span id="hud-thru" class="text-white text-3xl font-black mono tracking-tighter">0000</span>
        </div>
    </header>

    <div class="flex-1 flex gap-6 overflow-hidden">
        <div class="flex-[3] relative bg-[#0a0a0c] rounded-3xl overflow-hidden border border-white/5 shadow-2xl">
            <svg id="svg" viewBox="0 0 800 600" class="w-full h-full">
                <rect width="800" height="600" fill="#0a0a0c" />
    
                <!-- Grid Background -->
                <defs>
                    <pattern id="grid" width="40" height="40" patternUnits="userSpaceOnUse">
                        <path d="M 40 0 L 0 0 0 40" fill="none" stroke="rgba(255,255,255,0.02)" stroke-width="1"/>
                    </pattern>
            </defs>
            <rect width="800" height="600" fill="url(#grid)" />
    
                <!-- Road Infrastructure -->
                <g stroke="#161618" stroke-width="100">
                    <line x1="400" y1="0" x2="400" y2="600" />
                    <line x1="0" y1="300" x2="800" y2="300" />
                </g>

                <!-- Dashed Center Lines -->
                <g stroke="white" stroke-width="1" stroke-dasharray="8,12" opacity="0.1">
                    <line x1="400" y1="0" x2="400" y2="250" />
                    <line x1="400" y1="350" x2="400" y2="600" />
                    <line x1="0" y1="300" x2="350" y2="300" />
                    <line x1="450" y1="300" x2="800" y2="300" />
                </g>

                <!-- White Stop Lines (matching your screenshot) -->
                <g stroke="white" stroke-width="3" opacity="0.5">
                    <line x1="400" y1="250" x2="450" y2="250" /> <!-- North -->
                    <line x1="350" y1="350" x2="400" y2="350" /> <!-- South -->
                    <line x1="350" y1="300" x2="350" y2="350" /> <!-- West -->
                    <line x1="450" y1="250" x2="450" y2="300" /> <!-- East -->
                </g>
    
                <g id="lights-layer"></g>
                <g id="vehicles-layer"></g>
            </svg>
            
            <div class="absolute bottom-8 left-8 flex gap-12 text-[11px] font-bold uppercase">
                <div class="flex flex-col"><span class="text-white/20 text-[9px] mb-1">Signal</span><span id="hud-signal" class="text-indigo-400 text-sm"></span></div>
                <div class="flex flex-col"><span class="text-white/20 text-[9px] mb-1">Timer</span><span id="hud-timer" class="text-white text-sm"></span></div>
            </div>
        </div>
        <div class="flex-1 bg-[#0c0c0e] border border-white/5 rounded-3xl p-6">
            <h3 class="text-indigo-400 text-[10px] font-bold uppercase tracking-widest mb-4">Approach Density</h3>
            <div id="side-counts" class="space-y-2"></div>
        </div>
    </div>

    <script>
        const cx = 400, cy = 300, roadHalf = 50, laneOffset = 22;
        let localVehicles = new Map();
        let signalState = { signal: '', timer: 0 };
        let lastTimestamp = performance.now();

        async function sync() {
            try {
                const res = await fetch('/data');
                const data = await res.json();
                signalState = { signal: data.current_signal, timer: data.timer };
                document.getElementById('hud-signal').innerText = data.current_signal.replace('_', ' ');
                document.getElementById('hud-timer').innerText = data.timer > 0 ? Math.ceil(data.timer) + 's' : "WAIT";
                document.getElementById('hud-thru').innerText = data.throughput.toString().padStart(4, '0');

                const serverIds = new Set(data.vehicles.map(v => v.id));
                data.vehicles.forEach(sv => {
                    if (!localVehicles.has(sv.id)) {
                        localVehicles.set(sv.id, { ...sv });
                    } else {
                        let lv = localVehicles.get(sv.id);
                        if (!sv.moving) lv.progress = sv.progress;
                        else lv.progress = lv.progress * 0.3 + sv.progress * 0.7;
                        lv.moving = sv.moving;
                    }
                });
                for (let id of localVehicles.keys()) if (!serverIds.has(id)) localVehicles.delete(id);

                const counts = {NORTH:0, EAST:0, SOUTH:0, WEST:0};
                data.vehicles.forEach(v => { if(v.progress < 0.8) counts[v.lane]++; });
                document.getElementById('side-counts').innerHTML = Object.entries(counts).map(([l, val]) => `
                    <div class="flex justify-between items-center p-3 bg-white/5 border border-white/5 rounded-xl">
                        <span class="text-[10px] font-black text-white/30 uppercase">${l}</span>
                        <span class="text-xl font-black text-indigo-400 font-mono">${val}</span>
                    </div>`).join('');
            } catch (e) {}
        }
        setInterval(sync, 100);

        function animate(now) {
            const dt = (now - lastTimestamp) / 1000;
            lastTimestamp = now;
            localVehicles.forEach(v => { if (v.moving || v.progress > 0.82) v.progress += v.speed * dt; });

            const lLayer = document.getElementById('lights-layer');
            lLayer.innerHTML = '';
            ['NORTH', 'EAST', 'SOUTH', 'WEST'].forEach(dir => {
                let lx, ly;
                if(dir === 'NORTH') { lx = 340; ly = 240; } else if(dir === 'SOUTH') { lx = 460; ly = 360; }
                else if(dir === 'EAST')  { lx = 460; ly = 240; } else if(dir === 'WEST')  { lx = 340; ly = 360; }
                const isGreen = signalState.signal === dir + '_GREEN';
                const isYellow = signalState.signal === dir + '_YELLOW';
                lLayer.innerHTML += `<circle cx="${lx}" cy="${ly}" r="8" fill="${isGreen?'#10b981':(isYellow?'#fbbf24':'#ef4444')}" opacity="${(isGreen||isYellow)?1:0.2}" />`;
            });

            const vLayer = document.getElementById('vehicles-layer');
            vLayer.innerHTML = '';
            localVehicles.forEach(v => {
                const { x, y, rotate } = calculateCoords(v);
                vLayer.innerHTML += `
                    <g transform="translate(${x},${y}) rotate(${rotate})">
                        <rect x="-18" y="-12" width="36" height="24" rx="5" fill="${v.color}" />
                        <rect x="7" y="-9" width="9" height="18" rx="1" fill="white" opacity="0.3" />
                        ${v.turn === 'left' ? `<circle cx="-12" cy="-9" r="3.5" fill="#facc15" class="blinker" />` : ''}
                    </g>`;
            });
            requestAnimationFrame(animate);
        }

        function calculateCoords(v) {
            let x, y, rotate, p = v.progress, roadLen = 300;
    
             if (p <= 1.0) {
                // Entry Phase (Heading toward center)
                if (v.lane === 'NORTH') { x = cx + laneOffset; y = cy - roadHalf - (1 - p) * roadLen; rotate = 90; }
                    else if (v.lane === 'SOUTH') { x = cx - laneOffset; y = cy + roadHalf + (1 - p) * roadLen; rotate = 270; }
                    else if (v.lane === 'WEST') { x = cx - roadHalf - (1 - p) * roadLen; y = cy + laneOffset; rotate = 0; }
                    else if (v.lane === 'EAST') { x = cx + roadHalf + (1 - p) * roadLen; y = cy - laneOffset; rotate = 180; }
            } else {
                // Junction & Exit Phase
                const t = (p - 1.0) / 0.5; // Exit speed factor
                let sX, sY, eX, eY, cpX, cpY, sRot, eRot;

                if (v.lane === 'NORTH') {
                    sX = cx + laneOffset; sY = cy - roadHalf; sRot = 90;
                    if (v.turn === 'straight') { eX = cx + laneOffset; eY = cy + 500; eRot = 90; }
                    else { eX = cx + 500; eY = cy + laneOffset; cpX = cx + laneOffset; cpY = cy + laneOffset; eRot = 0; }
        } 
        else if (v.lane === 'SOUTH') {
                    sX = cx - laneOffset; sY = cy + roadHalf; sRot = 270;
                    if (v.turn === 'straight') { eX = cx - laneOffset; eY = cy - 500; eRot = 270; }
                    else { eX = cx - 400; eY = cy - laneOffset; cpX = cx - laneOffset; cpY = cy - laneOffset; eRot = 180; }
        } 
        else if (v.lane === 'WEST') {
                    sX = cx - roadHalf; sY = cy + laneOffset; sRot = 0;
                    if (v.turn === 'straight') { eX = cx + 500; eY = cy + laneOffset; eRot = 0; }
                    else { 
                        eX = cx - laneOffset; eY = cy - 400; 
                        cpX = cx - laneOffset; cpY = cy + laneOffset; 
                        eRot = -90; // FIXED: Changed 270 to -90 to stop the 360 spin
            }
        } 
        else if (v.lane === 'EAST') {
            sX = cx + roadHalf; sY = cy - laneOffset; sRot = 180;
            if (v.turn === 'straight') { eX = cx - 400; eY = cy - laneOffset; eRot = 180; }
            else { eX = cx + laneOffset; eY = cy + 500; cpX = cx + laneOffset; cpY = cy - laneOffset; eRot = 90; }
        }

        if (v.turn === 'straight') {
            x = sX + (eX - sX) * t;
            y = sY + (eY - sY) * t;
            rotate = sRot;
        } else {
            // Quadratic Bezier Curve for Smooth Turning
            const iT = 1 - t;
            x = iT * iT * sX + 2 * iT * t * cpX + t * t * eX;
            y = iT * iT * sY + 2 * iT * t * cpY + t * t * eY;
            // Smoothly rotate toward the exit angle
            rotate = sRot + (eRot - sRot) * t;
        }
    }
    return { x, y, rotate };
}
        requestAnimationFrame(animate);
    </script>
</body>
</html>